---
name: AOC 2023 - Day 1
description: |
    This is the first day of the Advent of Code 2023. The goal is to find the
    sum of all numbers in the input file.
---

### AOC 2023 Day 1: Trebuchet?!

The first day of the Advent of Code 2023 is here!

#### - Part 1

The first challenge of the year is to parse our input, which seems to be a jumbled mess of characters, for calibration numbers that the elves seem to have misplaced.

For each line of our input, we want to find the first and last digit, concatenate these together, and in the end sum every lines calibration number to produce your solution.

We're given the example:

```
1abc2
pqr3stu8vwx
a1b2c3d4e5f
treb7uchet
```

In the first line, `1abc2`, the first digit is `1` and the last digit is `2`. Concatenating these gives us the calibration number `12` for the first line.

The 2nd, 3rd and 4th line gives us the calibration numbers `38`, `15` and `77`. Notably in the last string, the only character present is `7`, therefore the first and last digit are both `7`.

Adding all these up would give us `77`.

I decided to write this days solution in Python3.

Everyday starts with you reading in your input, which I opted to do using the [aocd](https://pypi.org/project/advent-of-code-data/) Python library. This, among many other features, allows you to import and have your input with only 2 lines of code.

```python
from aocd import get_data
lines = get_data(day=1, year=2023).split("\n")
```

I instantly split it based upon the new-line character which returns me an array of strings, perfect for iterating over.

Next, I prepare a `total` counter which I'm going to add too as I iterate over each line in my input.

For each line:

-   I create a new `numbers` array and then iterate over each character within the string to find all the digits.
-   I iterate over each character, using `enumerate` which allows me to access both the characters index and value at the same time
-   For any characters which are digits, which I can check using Python's `is_digit()` method, I add their index to my `numbers` array
-   Finally, I get the first and last digits that showed up by indexing my `numbers` array with the index `0` and `-1` respectively.
-   As these digits are still strings, we can simply concatenate them using `+`, before converting them to an integer and adding to our total counter.

```python
total = 0
for line in lines:
    numbers = []
    for char_index, char in enumerate(line):
        if char.isdigit():
            numbers.append(char)
    total += int(numbers[0] + numbers[-1])

print(total)
```

And that's Part 1 completed!

#### - Part 2

Part 2 makes things a bit harder as it turns out in the jumbled mess of characters, we also need to look out for words that correspond to numbers, and not just digits themselves.

For example, in Part 1, given the input:

```
9eightone
hczsqfour3nxm5seven4
```

The first and last digit to show up in line 1 is `9`, and in line 2 is `34`.

However, as we are now considering words, the first number that appears in `9eightone` is still 9, however the last is now `one`, meaning the calibration number should be `91`, and not `99`.

One approach taken which may backfire is to simply scan through and replace all string words with their number equivalent, then rerun the same logic as Part 1.

This would look something like this:

-   Starting with: `9eightone`
-   `eight` is replaced with `8` -> `98one`
-   `one` is replaced with `1` -> `981`

Now, rerunning our logic from Part 1 gives us the correct calibration number of `91`.

However, I stated previously that this may backfire - As our inputs are not so kind, and there is a case which you may not have considered.

Consider the string:

`nineight`

Do you see what could go wrong?

Let's scan through again:

-   Starting with `nineight`
-   `nine` is replaced with `9` -> `9ight`

And there's no more strings to replace! So our calibration number is 99 right? We've managed to lose the `eight` as the `e` at the end of `nine` and start of `eight` was lost.

There's several counters to this including replacing `nine` with `nine9nine` (which you could do for all numbers), or as some people did, `nine` would be replaced with `n9e`, as there is only at-most a 1 letter crossover between any number string.

However, my approach was different when the puzzle first released, and rather, as I scanned through looking for digits, I also took substrings of the original line and checked to see if it began with any numbers.

I started with creating an array of each number word, and notably each number's index lines up with it's corresponding value

```python
words =  ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"]
```

Next, I cut off `1` letter from the start of each string at a time and checked whether it started with any numbers. If so, I added their index to the numbers array

````python
for char_index, char in enumerate(line):
    if char.isdigit():
        numbers.append(char)
    for number in words:                              # Iterate over each number word
        if line[char_index:].startswith(number):      # If the line substringed starts with the number word, then
            numbers.append(str(words.index(number)))  # Add it's digit equivalent into the numbers array (converted to a string for consistency with P1)```
````

Finally, the complete code for P2 looks like this:

```python
from aocd import get_data
lines = get_data(day=1, year=2023).split("\n")

words =  ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"]
total = 0

for line in lines:
    numbers = []
    for char_index, char in enumerate(line):
        if char.isdigit():
            numbers.append(char)
        for number in words:
            if line[char_index:].startswith(number):
                numbers.append(str(words.index(number)))

    total += int(numbers[0] + numbers[-1])

print(total)
```

And that sums it up for 2023 Day 1 :)
I placed 98th in Part 1 and 27th in Part 2, so not a bad start!
